c
processor.register(source)
puts source
source
processor.register(source) + immediate
n
step
n
step
c
exit
n
immediate
n
step
n
step
instruction.to_s
c
exit
processor.register(source)
immediate
c
n
@registers[1]
instruction.to_s
n
destination - 4
n
value
n
processor.register(source) + immediate
processor.register(source)
n
destination
direction
n
sign
n
step
n
step
instruction.to_s
c
exit
load(pc).unpack("S*").first.to_s(16)
load(pc).unpack("S*")
load(pc).size
load(pc)
pc
instruction.to_s
c
instruction.pc_modified?
n
c
exit
instruction.to_s
c
instruction.to_s
c
exit
n
step
n
step
instruction.to_s
c
exit
n
step
n
step
instruction.to_s
c
exit
instruction.to_s
c
exit
((msb & 0xC) / 4).to_s(16)
(msb & 0xC) / 4.to_s(16)
(msb & 0xC).to_s(16)
msb.to_s(16)
msb
to_s
destination
n
value
n
step
n
step
c
exit
pc
instruction.to_s
c
instruction.to_s
c
exit
instruction.to_s
c
n
instruction.to_s
instruction
instruction.original
c
exit
eixt
instruction.original
instruction
c
n
step
n
step
c
n
exit
@operation
@imm
exit
instruction.to_s.strip.gsub(/\/[^\/]*\//, '')
instruction
c
instruction
c
instruction
instruction\
c
instruction
c
instruction
c
instruction
c
instruction
c
instruction
c
instruction
c
instruction
c
instruction
c
instruction
c
instruction
c
instruction
c
instruction
c
instruction
c
instruction
exit
original
operation
components
to_parse
exit
component
 exit
load(pc).unpack("S*").first
pc
n
step
value
n
step
n
step
n
exit
n
(processor.pc & 0xFF00) | immediate
step
n
step
n
step
n
exit
@processor.pc
processor.pc
step
n
step
n
step
n
exit
step
source
n
destination
n
immediate
msb
n
step
n
step
n
c
step
n
msb
n
step
n
[@instruction].pack("S>*").unpack("C*").map { |i| i.to_s(16) }
@instruction.to_s(16)
@instruction
[@instruction].pack("S>*").unpack("C*")
n
step
n
c
n
step
n
instruction = load(pc).unpack("S*")
step
exit
local_address
step
load(@pc).unpack("S*")
step
exit
c
exit
c
n
bytes.size
bytes
n
output.size
output
n
words
n
exit
words.pack("S*")
[words.first].pack("S")
words.first.pack("S")
words.pack("S")
words.pack("C")
words.size
c
exit
bytes
bytes.unpack("C")
bytes.unpack("s")
bytes.unpack("S")
