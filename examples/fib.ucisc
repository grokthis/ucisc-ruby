# Compute Fibonacci numbers
#
# By default, computes fib(8) == 21. Change the immediate on line 24
# to compute other numbers. fib(0x18) is the maximum value that will
# compute correctly. fib(0x19) and up will overflow 16-bits.
#
# To run:
#   $ exe/ucisc examples/fib.ucisc
#
# When the debugger pauses, get the output by entering:
#
#   instruction.unpack(load(register(1)))
#
# This will give you the value of 1.mem which is pointing to the end of the stack

#== code 0x0000

Entry:
  # Initialize the stack register to 0xFFFF (which is -1 sign extended)
  0/load 0xFFFF to sp/    4.val -1.imm 5.reg

  # Prep factorial call
  0/set return address on stack/     0.reg/pc/ finish.disp 1.mem/sp/ 1.inc
 
  # Call fib
  0/load fib arg/                    4.val 8.imm 1.mem/sp/ 1.inc
  0/call fib/                        0.reg/pc/ fib.disp 0.reg/pc/

finish:

  0/Jump to Entry/                   0.reg/pc/ Entry.disp 0.reg/pc/

fib:
  # fib(0) == 0
  202/or arg with itself/            1.mem/sp/ 1.mem 1.sign 7.eff/set flags, don't store/
  {
    0/break if not 0/                0.reg/pc/ break.disp 0.reg/pc/ 1.eff/not zero/
    0/jump return/                   1.mem/sp/ 2.imm 0.reg/pc/
  } 

  # fib(1) == 1
  0/load 1 into r2/                  4.val 1.imm 6.reg
  20C/subtract 1 from arg/           6.reg/constant 1/ 1.mem/sp/ 1.sign 7.eff/don't store/
  {
    0/break if not zero/             0.reg/pc/ break.disp 0.reg/pc/ 1.eff/set if not zero/

    # fib(1) = 1
    0/jump return/                   1.mem/sp/ 2.imm 0.reg/pc/
  }

  # Recurse for fib(arg-1) and fib(arg-2)
  {
    0/push return address/           0.reg/pc/ break.disp 1.mem/sp/ 1.inc
    0/copy fib(n)/                   1.mem 4.imm 1.mem 1.inc

    0/load 1 into r2/                4.val 1.imm 6.reg/1 constant/
    20C/subtract 1 from n/           6.reg/constant 1/ 1.mem/sp/

    0/call fib/                      0.reg/pc/ fib.disp 0.reg/pc/
  }
  {
    0/push return address/           0.reg/pc/ break.disp 1.mem/sp/ 1.inc
    0/copy fib(n)/                   1.mem 8.imm 1.mem 1.inc

    0/load 2 into r2/                4.val 2.imm 6.reg/1 constant/
    20C/subtract 2 from n/           6.reg/constant 1/ 1.mem/sp/

    0/call fib/                      0.reg/pc/ fib.disp 0.reg/pc/
  }
 
  0/load &fib(n-1)/                  1.mem/sp/ 4.imm 6.reg/fib(n-1)/ 
  20A/fib(n-1) + fib(n-2)/           6.reg 1.mem/sp/
  0/copy fib(n) to r2/               1.mem/sp/ 0.imm 6.reg
  
  0/pop recursive calls from sp/     5.reg/sp/ 8.imm 5.reg/sp/
  0/copy fib(n) to stack/            6.reg/fib(n)/ 0.imm 1.mem/sp/

  0/jump return/                     1.mem/sp/ 2.imm 0.reg/pc/

