# A recursive factorial algorithm
# Inspired by the SubX example near the bottom of this post:
# http://akkartik.name/post/mu-2019-1
#
# The goal is to compare the implementation of the uCISC ISA to x86
# as well as roughly see how things line up with SubX and look for
# the coming MuCISC goals
#
# To run:
#   $ exe/ucisc examples/factorial.ucisc
#
# Type 'break' when you hit the breakpoint, then `load(register(1))`
# to view the result on the stack
#
# More instructions on the compiler and debugger are in the README.md
# Or use GitHub https://github.com/grokthis/ucisc-ruby#usage

# Setup some simple syntax sugar for easy reference to stack and pc
$stack as 1.mem
$&stack as 1.reg
$pc as 0.reg

# Simple conditional syntax sugar
$zero? as 0.eff
$not_zero? as 1.eff

Entry:
  # Init stack pointer
  copy 0.imm $&stack

  # Call factorial
  # Calling convention is to push args to stack, in order then push return address
  # On return, args and return address are removed, result is in it's place
  $stack[1] <= factorial(6.imm)

  # halt
  copy $pc $pc

factorial: # (n)
  # factorial(1) == 1
  compute 0xB.op/subtract/ 1.imm $stack push
  {
    copy $pc break.disp $pc $not_zero?
  
    # pop n-1 off stack 
    copy $stack 1.imm $stack 3.imm
    copy $&stack 2.imm $&stack

    # jump return, pop return address off stack
    copy $stack $pc pop
  } 

  # compute factorial(n-1)
  $stack[1] <= factorial($stack)

  # multiply n * factorial(n-1), cleanup stack
  compute 0xC.op $stack 2.imm $stack

  # copy $result, pop factorial(n)
  copy $stack $stack 4.imm
  copy $&stack 3.imm $&stack

  # return
  copy $stack $pc pop

