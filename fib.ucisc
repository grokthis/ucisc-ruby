# Compute the second Fibonacci number.
#
# To run:
#   $ exe/ucisc fib.ucisc

#== code 0x0000

Entry:
  # Initialize the stack register to 0xFFFF (which is -1 sign extended)
  0/copy/                            0.val 5.reg/stack pointer/ -1.imm 1.sign 

  # Prep fib call
  D/push arg, address/               1.reg/stack pointer/ 1.reg/stack pointer/ -2.imm
  0/set return address on stack/     0.reg/PC/ finish.disp 0.sign 1.mem/stack pointer/
 
  # Fibonacci of 2
  D/push arg to stack/               1.reg/stack pointer/ 1.reg/stack pointer/ -2.imm
  0/set fib arg to 2/                4.val 2.imm 0.sign 1.mem/stack pointer/
  0/call fib/                        0.reg/PC/ fib.disp 0.sign 0.reg/PC/

finish:

  203/xor pc with itself/            0.reg/PC/ 0.reg/PC/ 0.inc 2.eff/store value, drop flags/

fib:
  # fib(0) == 0
  D/set prep fib-1 jump/             0.reg/PC/ fib-1.imm 2.reg/call pointer/
  202/or arg with itself/            1.mem/stack pointer/ 1.mem 0.inc 3.eff/store and set flags/
  200/jump if arg not zero/          6.reg/fib-1 address/ 0.reg/PC/ 0.inc 1.eff/set if not zero/
 
  # fib(0) == 0
  0/jump return/                     1.mem/stack pointer/ 2.imm 0.sign 0.reg/PC/

fib-1:
  # fib arg is on stack, prepare variable with 1
  D/push var to stack/               1.reg/stack pointer/ 2.reg/var/ -2.imm
  0/set arg to 1/                    4.val 1.imm 0.sign 2.mem/var/

  D/prep fib-recurse jump/           0.reg/PC/ fib-recurse.imm 3.reg
  20C/subtract 1 from arg/           2.mem/var/ 1.mem/stack pointer/ 0.inc 3.eff/store/
  200/jump if arg not zero/          7.reg/fib-recurse address/ 0.reg/PC/ 0.inc 1.eff/set if not zero/

  # fib(1) = 1
  0/store 1 in return value/         4.val 1.imm 0.sign 1.mem/stack pointer/
  0/jump return/                     1.mem/stack pointer/ 2.imm 0.sign 0.reg/PC/

fib-recurse:
  # Prep fib call
  D/push address/                    1.reg/stack pointer/ 1.reg/stack pointer/ -2.imm
  0/set return address on stack/     0.reg/PC/ fib-recurse-2.disp 0.sign 1.mem/stack pointer/

  D/push arg to stack/               1.reg/stack pointer/ 1.reg/stack pointer/ -2.imm
  0/set fib arg to arg-1/            1.mem/stack pointer/ -4.imm 1.sign 1.mem/stack pointer/
  0/call fib/                        0.reg/PC/ fib.disp 1.sign 0.reg/PC/

fib-recurse-2:
  # Prep fib call
  D/push address/                    1.reg/stack pointer/ 1.reg/stack pointer/ -2.imm
  0/set return address on stack/     0.reg/PC/ fib-finish.disp 1.sign 1.mem/stack pointer/

  # fib - 1 - 1 => fib - 2 : put this on the stack
  D/push var to stack/               1.reg/stack pointer/ 1.reg/stack pointer/ -2.imm
  0/set var to -1/                   4.val -1.imm 1.sign 1.mem/stack pointer/
  D/pointer to arg - 1/              1.reg/stack pointer/ 2.reg/stack pointer/ -4.imm
  20B/set val to arg - 2/            2.mem/arg - 1/ 1.mem/value of -1/ 0.inc 3.eff/store/

  0/call fib/                        0.reg/PC/ fib.disp 1.sign 0.reg/PC/

fib-finish:
  # Current stack: [return pointer, arg - 2, address, fib(arg-1), address, fib(arg-2)]
  D/pointer to fib(arg-1)/           1.reg/stack pointer/ -4.imm 2.reg/fib(arg - 1)/
  20A/add fib(arg-1) + fib(arg-2)/   2.mem/fib(arg-1)/ 1.mem/fib(arg-2)/ 0.inc 3.eff/store/

  # Clear stack
  0/copy result to return location/  1.mem/result/ 1.mem/result/ -8.imm 1.sign
  D/pop from stack/                  1.reg/stack pointer/ 1.reg/stack pointer/ 8.imm

  # return result
  0/jump return/                     1.mem/stack pointer/ 2.imm 0.sign 0.reg/PC/

